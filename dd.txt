Definir un fitxer d'esquema

L’XSD està basat en XML i, per tant, ha de complir amb les regles d’XML:

    Tot i que no és obligatori normalment sempre es comença el fitxer amb la declaració XML.
    Només hi ha un element arrel, que en aquest cas és <schema>.

Com que no s’està generant un document XML lliure sinó que s’està fent servir un vocabulari concret i conegut per poder fer servir els elements XML sempre s’hi haurà d’especificar l’espai de noms d’XSD: ”http://www.w3.org/2001/XMLSchema”.

    <?xml version="1.0" ?>
    <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
        ...
    </xs:schema>

En la declaració d’aquest espai de noms s’està definint que xs és l’àlies per fer referència a totes les etiquetes d’aquest espai de noms. Els àlies per a XSD normalment són xs o xsd, però en realitat no importa quin es faci servir sempre que es faci servir el mateix en tot el document.

Etiquetes d'XSD

L’XSD defineix moltes etiquetes i no es veuran totes aquí. Podeu trobar totes les etiquetes possibles en l’especificació www.w3.org/TR/xmlschema11-1 .

L’etiqueta <schema> pot tenir diferents atributs, alguns dels quals podem veure en la taula.8.
Taula: Atributs de l’etiqueta <schema>
Atribut 	Significat
attributeFormDefault 	Pot ser qualified si fem que sigui obligatori posar l’espai de noms davant dels atributs o unqualified si no ho fem. Per defecte es fa servir unqualified.
elementFormDefault 	Serveix per definir si cal l’espai de noms davant del nom. Pot prendre els valors qualified i unqualified.
version 	Permet definir quina versió del document d’esquemes estem definint (no és la versió d’XML Schemas).

A partir de l’etiqueta arrel ja es poden començar a definir les etiquetes del vocabulari que es vol crear.
Definició d'elements

Els elements es defineixen tal com es veu a la figura.11, fent servir l’etiqueta <element>, i amb atributs s’hi especifica com a mínim el nom i opcionalment el tipus de dades que contindrà l’element.
Figura Definició d’un element

L’XSD divideix els elements en dos grans grups basant-se en les dades que contenen:

    Elements amb contingut de tipus simple: són elements sense atributs que només contenen dades.
    Elements amb contingut de tipus complex: són elements que poden tenir atributs, no tenir contingut o contenir elements.

A partir de la definició es pot veure que gairebé sempre hi haurà algun tipus complex, ja que l’arrel normalment contindrà altres elements.
Elements amb contingut de tipus simple

Es consideren elements amb contingut de tipus simple aquells que no contenen altres elements ni tenen atributs.

La versió 1.1 d’XSD defineix una cinquantena de tipus de dades diferents, que es poden trobar a la seva definició (www.w3.org/TR/xmlschema11-2). Entre els més usats en destaquen els de la taula.9.
Taula: Tipus de dades més usats en XSD
Tipus 	Dades que s’hi poden emmagatzemar
string 	Cadenes de caràcters
decimal 	Valors numèrics
boolean 	Només pot contenir ‘true’ o ‘false’ o (1 o 0)
date 	Dates en forma (AAAA-MM-DD)
anyURI 	Referències a llocs (URL, camins de disc…)
base64binary 	Dades binàries codificades en base64
integer 	Nombres enters

A partir dels tipus bàsics, l’estàndard en crea d’altres amb l’objectiu de tenir tipus de dades que es puguin adaptar millor als objectius de qui dissenya l’esquema. En aquest sentit apareixen els tipus anomenats positiveInteger, nonNegativeInteger, gYearMonth, unsignedInt…

Els tipus de dades permeten restringir els valors que contindran les etiquetes XML. Per exemple, si es parteix de la definició següent:

    <xs:element name="posicio" type="xs:integer"/>
    </xs:schema>

Només s’aconseguirà validar un element si el seu contingut és un nombre enter. Per exemple, l’exemple següent no validarà:

    <posicio>Primer</posicio>

En la taula.10 es poden veure exemples de definicions d’elements i valors que hi validen.
Taula: Exemples d’elements i què s’hi pot validar
Etiqueta 	Exemple
<xs:element name=“dia” type=“xs:date” /> 	<dia>2011-09-15</dia>
<xs:element name=“alçada” type=“xs:integer”/> 	<alçada>220</alçada>
<xs:element name=“nom” type=“xs:string”/> 	<nom>Pere Puig</nom>
<xs:element name=“mida” type=“xs:float”/> 	<mida>1.7E2</mida>
<xs:element name=“lloc” type=“xs:anyURI”/> 	<lloc>http://www.ioc.cat</lloc>

Quan es defineix una etiqueta en XSD s’està definint que l’etiqueta haurà de sortir en el document XML una vegada. És bastant habitual que hi hagi etiquetes que es repeteixin un nombre determinat de vegades. En XSD això s’ha simplificat per mitjà d’uns atributs de l’etiqueta <element> que determinen la cardinalitat dels elements:

    minOccurs: permet definir quantes vegades ha de sortir un element com a mínim. Un valor de ‘0’ indica que l’element pot no sortir.
    maxOccurs: serveix per definir quantes vegades com a màxim pot sortir un element. unbounded implica que no hi ha límit en les vegades que pot sortir.

Fent servir els atributs es pot definir que l’element <nom> ha de sortir una vegada i l’element <cognom> un màxim de dues vegades.

    <xs:element name="nom" />
    <xs:element name="cognom" maxOccurs="2"/>

També es poden donar valors als elements amb els atributs fixed, default i nullable.

L’atribut fixed permet definir un valor obligatori per a un element:

    <xs:element name="centre" type="xs:string" fixed="IOC"/>

De manera que només es podrà definir el contingut amb el valor especificat (o sense res):

    <centre />
    <centre>IOC</centre>

Però mai un valor diferent de l’especificat:

    <centre>Institut Cendrassos</centre>

A diferència de fixed, default assigna un valor per defecte però deixa que sigui canviat en el contingut de l’etiqueta.

    <xsi:element name="centre" type="xs:string" default="IOC" />

La definició permetria validar amb els tres casos següents:

    <centre />
    <centre>IOC</centre>
    <centre>Institut Cendrassos</centre>

L’atribut nullable es fa servir per dir si es permeten continguts nuls. Per tant, només pot prendre els valors yes o no.
Tipus simples personals

Com que a vegades pot interessar definir valors per als elements que no han de coincidir necessàriament amb els estàndards, l’XSD permet definir tipus de dades personals. Per exemple, si es vol un valor numèric però que no accepti tots els valors sinó un subconjunt dels enters.

Per definir tipus simples personals no es posa el tipus a l’element i s’hi defineix un fill <simpleType>.

    <xs:element name="persona">
        <xs:simpleType>
           ...
        </xs:simpleType>
    </xs:element>

Dins de simpleType s’especifica quina és la modificació que s’hi vol fer. El més corrent és que les modificacions sigui fetes amb list, union, restriction o extension.

A pesar que es poden definir llistes de valors no es recomana gaire fer-ne servir. La majoria dels experts creuen que és millor definir els valors de la llista fent servir repeticions d’etiquetes.

Fer servir list permetrà definir que un element pot contenir llistes de valors. Per tant, per especificar que un element <partits> pot contenir una llista de dates es definiria:

    <xs:element name="partits">
      <xs:simpleType>
          <xs:list itemType="xs:date"/>
      </xs:simpleType>
    </xs:element>

L’etiqueta validaria amb una cosa com:

    <partits> 2011-01-07 2011-01-15 2011-01-21</partits>

Els elements simpleType també es poden definir amb un nom fora dels elements i posteriorment usar-los com a tipus de dades personal.

    <xs:simpleType name="dies">
        <xs:list itemType="xs:date"/>
    </xs:simpleType>
     
    <xs:element name="partits" type="dies"/>

Fent servir els tipus personalitzats amb nom es poden crear modificacions de tipus union. Els modificadors union serveixen per fer que es puguin mesclar tipus diferents en el contingut d’un element.

La definició de l’element <preu> farà que l’element pugui ser de tipus valor o de tipus simbol.

    <xs:element name="preus">
        <xs:sipleType>
            <xs:union memberTypes="valor simbol"/>
        </xs:simpleType>
    </xs:element>

Amb això li podríem assignar valors com aquests:

    <preus>25 €</preus>

Però sense cap mena de dubte el modificador més interessant és el que permet definir restriccions als tipus base. Amb el modificador restriction es poden crear tipus de dades en què només s’acceptin alguns valors, que les dades compleixin una determinada condició, etc.

L’element <naixement> només podrà tenir valors enters entre 1850 i 2011 si es defineix d’aquesta manera:

    <xs:simpleType name="any_naixement">
        <xs:restricion base="xs:integer">
            <xs:maxInclusive value="2011"/>
            <xs:minInclusive value="1850"/>
        </xs:restriction>
    </xs:simpleType>
     
    <xs:element name="naixement" type="any_naixement"/>

Es poden definir restriccions de molts tipus per mitjà d’atributs (taula.11). Normalment els valors de les restriccions s’especifiquen en l’atribut value:
Taula: Atributs que permeten definir restriccions en XSD
Elements 	Resultat
maxInclusive / maxExclusive 	Es fa servir per definir el valor numèric màxim que pot agafar un element.
minInclusive / minExclusive 	Permet definir el valor mínim del valor d’un element.
length 	Amb lenght restringim la llargada que pot tenir un element de text. Podem fer servir <xs:minLength> i <xs:maxLenght> per ser més precisos.
enumeration 	Només permet que l’element tingui algun dels valors especificats en les diferents línies <enumeration>.
totalDigits 	Permet definir el nombre de dígits d’un valor numèric.
fractionDigits 	Serveix per especificar el nombre de decimals que pot tenir un valor numèric.
pattern 	Permet definir una expressió regular a la qual el valor de l’element s’ha d’adaptar per poder ser vàlid.

Per exemple, el valor de l’element <resposta> només podrà tenir un dels tres valors “A”, “B” o “C” si es defineix d’aquesta manera:

    <xs:element name="resposta">
        <xs:simpleType>
            <xs:enumeration value="A"/>
            <xs:enumeration value="B"/>
            <xs:enumeration value="C"/>
        </xs:simpleType>
    </xs:element>

Una de les restriccions més interessants són les definides per l’atribut pattern, que permet definir restriccions a partir d’expressions regulars. Com a norma general tenim que si s’especifica un caràcter en el patró aquest caràcter ha de sortir en el contingut; les altres possibilitats les podem veure a la taula.12
Taula: Definició d’expressions regulars
Símbol 	Equivalència
. 	Qualsevol caràcter
\d 	Qualsevol dígit
\D 	Qualsevol caràcter no dígit
\s 	Caràcters no imprimibles: espais, tabuladors, salts de línia…
\S 	Qualsevol caràcter imprimible
x* 	El de davant de * ha de sortir 0 o més vegades
x+ 	El de davant de + ha de sortir 1 o més vegades
x? 	El de davant de ? pot sortir o no
[abc] 	Hi ha d’haver algun caràcter dels de dins
[0-9] 	Hi ha d’haver un valor entre el dos especificats, amb aquests inclosos
x{5} 	Hi ha d’haver 5 vegades el que hi hagi al davant dels claudàtors
x{5,} 	Hi ha d’haver 5 o més vegades el de davant
x{5,8} 	Hi ha d’haver entre 5 i 8 vegades el de davant

Fent servir aquest sistema es poden definir tipus de dades molt personalitzats. Per exemple, podem definir que una dada ha de tenir la forma d’un DNI (8 xifres, un guió i una lletra majúscula) amb aquesta expressió:

    <xs:simpleType name="dni">
        <xs:restriction base="xs:string">
            <xs:pattern value="[0-9]{8}-[A-Z]"/>
        </xs:restriction>
    </xs:simpleType>

A part de les restriccions també hi ha l’element extension, que serveix per afegir característiques extra als tipus. No té gaire sentit que surti en elements de tipus simple però es pot fer servir, per exemple, per afegir atributs als tipus simples (cosa que els converteix en tipus complexos).
Elements amb contingut de tipus complex

Els elements amb contingut de tipus complex són aquells que tenen atributs, contenen altres elements o no tenen contingut.

Els elements amb contingut complex han rebut moltes crítiques perquè es consideren massa complicats, però s’han de fer servir perquè en tots els fitxers d’esquema normalment hi haurà un tipus complex: l’arrel del document.

Es considera que hi ha quatre grans grups de continguts de tipus complex:

    Els que en el seu contingut només tenen dades. Per tant, són com els de tipus simples però amb atributs.
    Els elements que en el contingut només tenen elements.
    Els elements buits.
    Els elements amb contingut barrejat.

Els elements amb tipus complex es defineixen especificant que el tipus de dades de l’element és <xs:complexType>.

    <xs:element name="classe">
        <xs:complexType>
              ....
        </xs:complexType>
    </xs:element>

De la mateixa manera que amb els tipus simples, es poden definir tipus complexos amb nom per reutilitzar-los com a tipus personalitzats.

    <xs:complexType name="curs">
         ... 
    </xs:complexType>
     
    <xs:element classe type="curs"/>

Atributs

Una característica bàsica d’XSD és que només els elements de tipus complex poden tenir atributs. En essència no hi ha gaires diferències entre definir un element o un atribut, ja que es fa de la mateixa manera però fent servir l’etiqueta attribute.

Els tipus de dades són els mateixos i, per tant, poden tenir tipus bàsics com en l’exemple següent:

    <xs:attribute name="número" type="xs:integer" />

S’hi poden posar restriccions de la mateixa manera que en els elements. En aquest exemple l’atribut any no pot tenir valors superiors a 2011 si es defineix d’aquesta manera:

    <xs:attribute name="any">
        <xs:simpleType>
            <xs:restriction base="xs:integer">
                <xs:maxInclusive value="2011"/>
            </xs:restriction>
        </xs:simpleType>
    </xs:attribute>

Tret que s’especifiqui el contrari, els atributs sempre són opcionals.

L’etiqueta <attribute> té una sèrie d’atributs que permeten definir característiques extra sobre els atributs (taula.13).
Taula: Atributs més importants de xs:attribute
Atribut 	Ús
use 	Permet especificar si l’atribut és obligatori (required), opcional (optional) o bé no es pot fer servir (prohibited).
default 	Defineix un valor per defecte.
fixed 	Es fa servir per definir valors obligatoris per als atributs.
form 	Permet definir si l’atribut ha d’anar amb l’àlies de l’espai de noms (qualified) o no (unqualified).

Per exemple, l’atribut any s’haurà d’especificar obligatòriament si es defineix de la manera següent:

    <xs:attribute name="any" type="xs:integer" use="required" />

'simpleContent'

Si l’element només conté text, el contingut de complexType serà un simpleContent. El simpleContent permet definir restriccions o extensions a elements que només tenen dades com a contingut.

La diferència més important és que en aquest cas es poden definir atributs en l’element. Els atributs s’afegeixen definint una extensió al tipus fet servir en l’element.

En aquest exemple l’element <Mida> té contingut de tipus enter i defineix dos atributs, llargada i amplada, que també són enters.

    <xs:complexType name="Mida">
        <xs:simpleContent>
            <xs:extension base="xs:integer">
               <xs:atribute name="llargada" type="xs:integer"/>
               <xs:atribute name="amplada" type="xs:integer"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

Contingut format per elements

Els elements que contenen altres elements també poden ser definits en XSD dins d’un <complexType> i poden ser alguns dels elements de la taula.14.
Taula: Elements per definir contingut complex
Etiqueta 	Serveix per
sequence 	Especificar el contingut com una llista ordenada d’elements.
choice 	Permet especificar elements alternatius.
all 	Definir el contingut com una llista desordenada d’elements.
complexContent 	Estendre o restringir el contingut complex.

L’element <sequence> és una de les maneres amb què el llenguatge XSD permet que s’especifiquin els elements que han de formar part del contingut d’un element. Fins i tot en el cas en què només hi hagi una sola etiqueta es pot definir com a una seqüència.

La condició més important que tenen és que els elements del document XML per validar han d’aparèixer en el mateix ordre en el qual es defineixen en la seqüència.

    <xs:element name="persona">
        <xs:complexContent>
            <xs:sequence>
                <xs:element name="nom" type="xs:string"/>
                <xs:element name="cognom" type="xs:string" maxOccurs="2"/>
                <xs:element name="tipus" type="xs:string" />
            </xs:sequence>
        </xs:complexContent>  
    </xs:element>

En l’exemple anterior es defineix que abans de l’aparició de <tipus> poden aparèixer un o dos cognoms.

    <persona>
        <nom>Marcel</nom>
        <cognom>Puig</cognom>
        <cognom>Lozano</cognom>
        <tipus>Professor</tipus>
    </persona>

No validarà cap contingut si algun element no està exactament en el mateix ordre.

    <persona>
        <tipus>Professor</tipus>
        <cognom>Puig</cognom>
        <nom>Marcel</nom>
    </persona>

Les seqüències poden contenir dins seu altres seqüències d’elements.

    <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified"> 
        <xs:element name="persona">
            <xs:complexType>
                <xs:sequence>
                    <xs:element name="nomcomplet">
                        <xs:complexType>
                            <xs:sequence>
                                <xs:element name="nom" type="xs:string"/>
                                <xs:element name="cognom" type="xs:string" maxOccurs="2"/> 
                            </xs:sequence>
                        </xs:complexType>
                    </xs:element>
                    <xs:element name="professió" type="xs:string"/>
                </xs:sequence>
            </xs:complexType>
        </xs:element>
    </xs:schema>

L’element <choice> serveix per fer que s’hagi de triar una de les alternatives de les que es presenten dins seu.

En aquest exemple l’element persona podrà contenir o bé l’etiqueta <nomCognoms> o bé <dni>, però no totes dues.

    <xs:complexType nom="persona">
      <xs:choice>
          <xs:element name="nomCognoms" type="xs:string"/>
          <xs:element name="dni" type="xs:string"/>
      </xs:choice>

Entre les alternatives hi pot haver seqüències o altres elements <choice>. La definició següent és un exemple més elaborat que l’anterior i permet que es pugui triar entre els elements <nom> i <cognom> o <dni>.

    <xs:choice>
        <xs:sequence>
            <xs:element name="nom" type="xs:string"/>
            <xs:element name="cognom" type="xs:string" maxOccurs="2"/>
        </xs:sequence>
        <xs:element name="dni" type="xs:string"/>
    </xs:choice>

La diferència més important entre l’element <all> i <sequence> és l’ordre. L’element <all> permet especificar una seqüència d’elements però permet que s’especifiquin en qualsevol ordre.

Per tant, si definim l’element <persona> de la manera següent:

    <xs:element name="persona">
        <xs:complexType>
            <xs:all>
                <xs:element name="nom"/>
                <xs:element name="cognom"/>
            </xs:all>
        </xs:complexType>
    </xs:element>

Ens servirà per validar tant aquest document:

    <persona>
        <nom>Pere</nom>
        <cognom>Garcia</nom>

com aquest:

    <persona>
        <cognom>Garcia</nom>
        <nom>Pere</nom>

Però sempre s’han de tenir en compte les limitacions d’aquest element que no eren presents en les seqüències ordenades:

    Dins seu només hi pot haver elements. No hi pot haver ni seqüències, ni alternatives.
    No es pot fer servir la cardinalitat en els elements que contingui, ja que provocaria un problema de no-determinisme.

Per tant, l’exemple següent no és correcte, ja que es demana que <cognom> pugui sortir dues vegades.

    <xs:all>
        <xs:element name="nom" type="xs:string"/>
        <xs:element name="cognom" maxOccurs="2" type="xs:string"/>
    </xs:all>

Una possible manera de permetre que es puguin especificar el nom i els dos cognoms en qualsevol ordre seria fer el següent:

    <xs:complexType>
        <xs:choice>
            <xs:sequence>
                <xs:element name="nom" type="xs:string"/>
                <xs:element name="cognom" type="xs:string" maxOccurs="2"/>
            </xs:sequence>
            <xs:sequence>
                <xs:element name="cognom" type="xs:string" maxOccurs="2"/>
                <xs:element name="nom" type="xs:string"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>

'complexContent'

L’etiqueta complexContent permet definir extensions o restriccions a un tipus complex que contingui contingut barrejat o només elements.

Això fa que amb una extensió es pugui ampliar un contingut complex ja existent o restringir-ne els continguts.

Per exemple, si ja hi ha definit un tipus de dades nomComplet en què hi ha els elements <nom> i <cognom> se’n pot reutilitzar la definició per definir un nou tipus de dades, agenda, en què s’afegeixi l’adreça de correu electrònic.

    <xs:complexType name="nomComplet">
      <xs:sequence>
          <xs:element name="nom" type="xs:string"/>
          <xs:element name="cognom" type="xs:string" maxOccurs="2"/>
      </xs:sequence>
    </xs:complexType>
     
    <xs:complexType name="agenda">
        <xs:complexContent>
            <xs:extension base="nomComplet">
                <xs:sequence>
                     <xs:element name="email" type="xs:string" />
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

D’aquesta manera es podrà definir un element de tipus agenda:

    <xs:element name="persona" type="agenda"/>

que haurà de tenir els tres elements <nom>, <cognom>, i <email>:

    <persona>
        <nom>Pere</nom>
        <cognom>Garcia</cognom>
        <email>pgarcia@ioc.cat</email>
    </persona>

Elements sense contingut

Per a XSD els elements sense contingut són sempre de tipus complex. En la definició simplement no s’especifica cap contingut i tindrem un element buit.

    <xs:element name="delegat">
        <xs:complexType />
    </xs:element>

La definició permet definir l’element d’aquesta manera:

    <delegat />

Si l’element necessita atributs simplement s’especifiquen dins del complexType.

    <xs:element name="delegat">
        <xs:complexType>
            <xs:attribute name="any" use="required" type="xs:gYear"/>
        </xs:complexType>
    </xs:element>

I ja es podrà definir l’atribut en l’element buit:

    <delegat any="2012"/>

Contingut barrejat

Els elements amb contingut barrejat són els elements que tenen de contingut tant elements com text. Es va pensar per poder incloure elements enmig d’un text narratiu.

En XSD el contingut barrejat es defineix posant l’atribut mixed=“true” en la definició del l’element <complexType>.

    <xs:element name="carta">
        <xs:complexType mixed="true">
            <xs:sequence>
                <xs:element name="nom" type="xs:string"/>
                <xs:element name="dia" type="xs:gDay"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

Això ens permetria validar un contingut com aquest:

    <carta>Estimat senyor <nom>Pere<nom>:
     
    Li envio aquesta carta per recordar-li que hem quedat per
    trobar-nos el dia <dia>12</dia>
    </carta>

Exemple de creació d'un XSD

Es poden crear definicions de vocabularis XSD a partir de la idea del que volem que continguin les dades o bé a partir d’un fitxer XML de mostra.
Enunciat

En un centre en què només s’imparteixen els cicles formatius d’SMX i ASIX, quan han d’entrar les notes als alumnes ho fan creant un arxiu XML com el següent:

    <?xml version="1.0" ?>
    <classe modul="3" nommodul="Programació bàsica">
        <curs numero="1" especialitat="ASIX">
            <professor>
                <nom>Marcel</nom>
                <cognom>Puig</cognom>
            </professor>
            <alumnes>
                <alumne>
                    <nom>Filomeno</nom>
                    <cognom>Garcia</cognom>
                    <nota>5</nota>
                </alumne>
                <alumne delegat="si">
                    <nom>Frederic</nom>
                    <cognom>Pi</cognom>
                    <nota>3</nota>
                </alumne>
                <alumne>
                    <nom>Manel</nom>
                    <cognom>Puigdevall</cognom>
                    <nota>8</nota>
                </alumne>
            </alumnes>
        </curs>
    </classe> 

A la secretaria necessiten que es generi la definició del vocabulari en XSD per comprovar que els fitxers que reben són correctes. 